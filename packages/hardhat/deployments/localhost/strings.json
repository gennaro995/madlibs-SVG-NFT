{
  "address": "0xCf7Ed3AccA5a467e9e704C703E8D87F634fB0Fc9",
  "abi": [
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "_len",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "_ptr",
              "type": "uint256"
            }
          ],
          "internalType": "struct strings.slice",
          "name": "self",
          "type": "tuple"
        },
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "_len",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "_ptr",
              "type": "uint256"
            }
          ],
          "internalType": "struct strings.slice",
          "name": "needle",
          "type": "tuple"
        }
      ],
      "name": "beyond",
      "outputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "_len",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "_ptr",
              "type": "uint256"
            }
          ],
          "internalType": "struct strings.slice",
          "name": "",
          "type": "tuple"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "_len",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "_ptr",
              "type": "uint256"
            }
          ],
          "internalType": "struct strings.slice",
          "name": "self",
          "type": "tuple"
        },
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "_len",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "_ptr",
              "type": "uint256"
            }
          ],
          "internalType": "struct strings.slice",
          "name": "other",
          "type": "tuple"
        }
      ],
      "name": "compare",
      "outputs": [
        {
          "internalType": "int256",
          "name": "",
          "type": "int256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "_len",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "_ptr",
              "type": "uint256"
            }
          ],
          "internalType": "struct strings.slice",
          "name": "self",
          "type": "tuple"
        },
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "_len",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "_ptr",
              "type": "uint256"
            }
          ],
          "internalType": "struct strings.slice",
          "name": "other",
          "type": "tuple"
        }
      ],
      "name": "concat",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "_len",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "_ptr",
              "type": "uint256"
            }
          ],
          "internalType": "struct strings.slice",
          "name": "self",
          "type": "tuple"
        },
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "_len",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "_ptr",
              "type": "uint256"
            }
          ],
          "internalType": "struct strings.slice",
          "name": "needle",
          "type": "tuple"
        }
      ],
      "name": "contains",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "_len",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "_ptr",
              "type": "uint256"
            }
          ],
          "internalType": "struct strings.slice",
          "name": "self",
          "type": "tuple"
        }
      ],
      "name": "copy",
      "outputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "_len",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "_ptr",
              "type": "uint256"
            }
          ],
          "internalType": "struct strings.slice",
          "name": "",
          "type": "tuple"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "_len",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "_ptr",
              "type": "uint256"
            }
          ],
          "internalType": "struct strings.slice",
          "name": "self",
          "type": "tuple"
        },
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "_len",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "_ptr",
              "type": "uint256"
            }
          ],
          "internalType": "struct strings.slice",
          "name": "needle",
          "type": "tuple"
        }
      ],
      "name": "count",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "cnt",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "_len",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "_ptr",
              "type": "uint256"
            }
          ],
          "internalType": "struct strings.slice",
          "name": "self",
          "type": "tuple"
        }
      ],
      "name": "empty",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "_len",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "_ptr",
              "type": "uint256"
            }
          ],
          "internalType": "struct strings.slice",
          "name": "self",
          "type": "tuple"
        },
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "_len",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "_ptr",
              "type": "uint256"
            }
          ],
          "internalType": "struct strings.slice",
          "name": "needle",
          "type": "tuple"
        }
      ],
      "name": "endsWith",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "_len",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "_ptr",
              "type": "uint256"
            }
          ],
          "internalType": "struct strings.slice",
          "name": "self",
          "type": "tuple"
        },
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "_len",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "_ptr",
              "type": "uint256"
            }
          ],
          "internalType": "struct strings.slice",
          "name": "other",
          "type": "tuple"
        }
      ],
      "name": "equals",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "_len",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "_ptr",
              "type": "uint256"
            }
          ],
          "internalType": "struct strings.slice",
          "name": "self",
          "type": "tuple"
        },
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "_len",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "_ptr",
              "type": "uint256"
            }
          ],
          "internalType": "struct strings.slice",
          "name": "needle",
          "type": "tuple"
        }
      ],
      "name": "find",
      "outputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "_len",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "_ptr",
              "type": "uint256"
            }
          ],
          "internalType": "struct strings.slice",
          "name": "",
          "type": "tuple"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "_len",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "_ptr",
              "type": "uint256"
            }
          ],
          "internalType": "struct strings.slice",
          "name": "self",
          "type": "tuple"
        },
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "_len",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "_ptr",
              "type": "uint256"
            }
          ],
          "internalType": "struct strings.slice[]",
          "name": "parts",
          "type": "tuple[]"
        }
      ],
      "name": "join",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "_len",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "_ptr",
              "type": "uint256"
            }
          ],
          "internalType": "struct strings.slice",
          "name": "self",
          "type": "tuple"
        }
      ],
      "name": "keccak",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "ret",
          "type": "bytes32"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "self",
          "type": "bytes32"
        }
      ],
      "name": "len",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "_len",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "_ptr",
              "type": "uint256"
            }
          ],
          "internalType": "struct strings.slice",
          "name": "self",
          "type": "tuple"
        }
      ],
      "name": "len",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "l",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "_len",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "_ptr",
              "type": "uint256"
            }
          ],
          "internalType": "struct strings.slice",
          "name": "self",
          "type": "tuple"
        },
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "_len",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "_ptr",
              "type": "uint256"
            }
          ],
          "internalType": "struct strings.slice",
          "name": "rune",
          "type": "tuple"
        }
      ],
      "name": "nextRune",
      "outputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "_len",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "_ptr",
              "type": "uint256"
            }
          ],
          "internalType": "struct strings.slice",
          "name": "",
          "type": "tuple"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "_len",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "_ptr",
              "type": "uint256"
            }
          ],
          "internalType": "struct strings.slice",
          "name": "self",
          "type": "tuple"
        }
      ],
      "name": "nextRune",
      "outputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "_len",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "_ptr",
              "type": "uint256"
            }
          ],
          "internalType": "struct strings.slice",
          "name": "ret",
          "type": "tuple"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "_len",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "_ptr",
              "type": "uint256"
            }
          ],
          "internalType": "struct strings.slice",
          "name": "self",
          "type": "tuple"
        }
      ],
      "name": "ord",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "ret",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "_len",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "_ptr",
              "type": "uint256"
            }
          ],
          "internalType": "struct strings.slice",
          "name": "self",
          "type": "tuple"
        },
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "_len",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "_ptr",
              "type": "uint256"
            }
          ],
          "internalType": "struct strings.slice",
          "name": "needle",
          "type": "tuple"
        }
      ],
      "name": "rfind",
      "outputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "_len",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "_ptr",
              "type": "uint256"
            }
          ],
          "internalType": "struct strings.slice",
          "name": "",
          "type": "tuple"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "_len",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "_ptr",
              "type": "uint256"
            }
          ],
          "internalType": "struct strings.slice",
          "name": "self",
          "type": "tuple"
        },
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "_len",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "_ptr",
              "type": "uint256"
            }
          ],
          "internalType": "struct strings.slice",
          "name": "needle",
          "type": "tuple"
        },
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "_len",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "_ptr",
              "type": "uint256"
            }
          ],
          "internalType": "struct strings.slice",
          "name": "token",
          "type": "tuple"
        }
      ],
      "name": "rsplit",
      "outputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "_len",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "_ptr",
              "type": "uint256"
            }
          ],
          "internalType": "struct strings.slice",
          "name": "",
          "type": "tuple"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "_len",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "_ptr",
              "type": "uint256"
            }
          ],
          "internalType": "struct strings.slice",
          "name": "self",
          "type": "tuple"
        },
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "_len",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "_ptr",
              "type": "uint256"
            }
          ],
          "internalType": "struct strings.slice",
          "name": "needle",
          "type": "tuple"
        }
      ],
      "name": "rsplit",
      "outputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "_len",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "_ptr",
              "type": "uint256"
            }
          ],
          "internalType": "struct strings.slice",
          "name": "token",
          "type": "tuple"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "_len",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "_ptr",
              "type": "uint256"
            }
          ],
          "internalType": "struct strings.slice",
          "name": "self",
          "type": "tuple"
        },
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "_len",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "_ptr",
              "type": "uint256"
            }
          ],
          "internalType": "struct strings.slice",
          "name": "needle",
          "type": "tuple"
        },
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "_len",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "_ptr",
              "type": "uint256"
            }
          ],
          "internalType": "struct strings.slice",
          "name": "token",
          "type": "tuple"
        }
      ],
      "name": "split",
      "outputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "_len",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "_ptr",
              "type": "uint256"
            }
          ],
          "internalType": "struct strings.slice",
          "name": "",
          "type": "tuple"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "_len",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "_ptr",
              "type": "uint256"
            }
          ],
          "internalType": "struct strings.slice",
          "name": "self",
          "type": "tuple"
        },
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "_len",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "_ptr",
              "type": "uint256"
            }
          ],
          "internalType": "struct strings.slice",
          "name": "needle",
          "type": "tuple"
        }
      ],
      "name": "split",
      "outputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "_len",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "_ptr",
              "type": "uint256"
            }
          ],
          "internalType": "struct strings.slice",
          "name": "token",
          "type": "tuple"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "_len",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "_ptr",
              "type": "uint256"
            }
          ],
          "internalType": "struct strings.slice",
          "name": "self",
          "type": "tuple"
        },
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "_len",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "_ptr",
              "type": "uint256"
            }
          ],
          "internalType": "struct strings.slice",
          "name": "needle",
          "type": "tuple"
        }
      ],
      "name": "startsWith",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "string",
          "name": "self",
          "type": "string"
        }
      ],
      "name": "toSlice",
      "outputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "_len",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "_ptr",
              "type": "uint256"
            }
          ],
          "internalType": "struct strings.slice",
          "name": "",
          "type": "tuple"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "self",
          "type": "bytes32"
        }
      ],
      "name": "toSliceB32",
      "outputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "_len",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "_ptr",
              "type": "uint256"
            }
          ],
          "internalType": "struct strings.slice",
          "name": "ret",
          "type": "tuple"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "_len",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "_ptr",
              "type": "uint256"
            }
          ],
          "internalType": "struct strings.slice",
          "name": "self",
          "type": "tuple"
        }
      ],
      "name": "toString",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "_len",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "_ptr",
              "type": "uint256"
            }
          ],
          "internalType": "struct strings.slice",
          "name": "self",
          "type": "tuple"
        },
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "_len",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "_ptr",
              "type": "uint256"
            }
          ],
          "internalType": "struct strings.slice",
          "name": "needle",
          "type": "tuple"
        }
      ],
      "name": "until",
      "outputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "_len",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "_ptr",
              "type": "uint256"
            }
          ],
          "internalType": "struct strings.slice",
          "name": "",
          "type": "tuple"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    }
  ],
  "transactionHash": "0x7ed7d6dc7d7564424c00846592fb8860611a3dc37b193b006d9d99bfb52e6fa0",
  "receipt": {
    "to": null,
    "from": "0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266",
    "contractAddress": "0xCf7Ed3AccA5a467e9e704C703E8D87F634fB0Fc9",
    "transactionIndex": 0,
    "gasUsed": "2049100",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x3eca06e55d7e89d5b88fe5172e3710e13028548c98f8c8d5df43916aa77dd02f",
    "transactionHash": "0x7ed7d6dc7d7564424c00846592fb8860611a3dc37b193b006d9d99bfb52e6fa0",
    "logs": [],
    "blockNumber": 4,
    "cumulativeGasUsed": "2049100",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "solcInputHash": "b12b4c2a94f7f71708836d7752c5ea90",
  "metadata": "{\"compiler\":{\"version\":\"0.8.4+commit.c7e474f2\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"_len\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_ptr\",\"type\":\"uint256\"}],\"internalType\":\"struct strings.slice\",\"name\":\"self\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"_len\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_ptr\",\"type\":\"uint256\"}],\"internalType\":\"struct strings.slice\",\"name\":\"needle\",\"type\":\"tuple\"}],\"name\":\"beyond\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"_len\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_ptr\",\"type\":\"uint256\"}],\"internalType\":\"struct strings.slice\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"_len\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_ptr\",\"type\":\"uint256\"}],\"internalType\":\"struct strings.slice\",\"name\":\"self\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"_len\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_ptr\",\"type\":\"uint256\"}],\"internalType\":\"struct strings.slice\",\"name\":\"other\",\"type\":\"tuple\"}],\"name\":\"compare\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"_len\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_ptr\",\"type\":\"uint256\"}],\"internalType\":\"struct strings.slice\",\"name\":\"self\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"_len\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_ptr\",\"type\":\"uint256\"}],\"internalType\":\"struct strings.slice\",\"name\":\"other\",\"type\":\"tuple\"}],\"name\":\"concat\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"_len\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_ptr\",\"type\":\"uint256\"}],\"internalType\":\"struct strings.slice\",\"name\":\"self\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"_len\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_ptr\",\"type\":\"uint256\"}],\"internalType\":\"struct strings.slice\",\"name\":\"needle\",\"type\":\"tuple\"}],\"name\":\"contains\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"_len\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_ptr\",\"type\":\"uint256\"}],\"internalType\":\"struct strings.slice\",\"name\":\"self\",\"type\":\"tuple\"}],\"name\":\"copy\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"_len\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_ptr\",\"type\":\"uint256\"}],\"internalType\":\"struct strings.slice\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"_len\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_ptr\",\"type\":\"uint256\"}],\"internalType\":\"struct strings.slice\",\"name\":\"self\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"_len\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_ptr\",\"type\":\"uint256\"}],\"internalType\":\"struct strings.slice\",\"name\":\"needle\",\"type\":\"tuple\"}],\"name\":\"count\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"cnt\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"_len\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_ptr\",\"type\":\"uint256\"}],\"internalType\":\"struct strings.slice\",\"name\":\"self\",\"type\":\"tuple\"}],\"name\":\"empty\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"_len\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_ptr\",\"type\":\"uint256\"}],\"internalType\":\"struct strings.slice\",\"name\":\"self\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"_len\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_ptr\",\"type\":\"uint256\"}],\"internalType\":\"struct strings.slice\",\"name\":\"needle\",\"type\":\"tuple\"}],\"name\":\"endsWith\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"_len\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_ptr\",\"type\":\"uint256\"}],\"internalType\":\"struct strings.slice\",\"name\":\"self\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"_len\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_ptr\",\"type\":\"uint256\"}],\"internalType\":\"struct strings.slice\",\"name\":\"other\",\"type\":\"tuple\"}],\"name\":\"equals\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"_len\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_ptr\",\"type\":\"uint256\"}],\"internalType\":\"struct strings.slice\",\"name\":\"self\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"_len\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_ptr\",\"type\":\"uint256\"}],\"internalType\":\"struct strings.slice\",\"name\":\"needle\",\"type\":\"tuple\"}],\"name\":\"find\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"_len\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_ptr\",\"type\":\"uint256\"}],\"internalType\":\"struct strings.slice\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"_len\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_ptr\",\"type\":\"uint256\"}],\"internalType\":\"struct strings.slice\",\"name\":\"self\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"_len\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_ptr\",\"type\":\"uint256\"}],\"internalType\":\"struct strings.slice[]\",\"name\":\"parts\",\"type\":\"tuple[]\"}],\"name\":\"join\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"_len\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_ptr\",\"type\":\"uint256\"}],\"internalType\":\"struct strings.slice\",\"name\":\"self\",\"type\":\"tuple\"}],\"name\":\"keccak\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"ret\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"self\",\"type\":\"bytes32\"}],\"name\":\"len\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"_len\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_ptr\",\"type\":\"uint256\"}],\"internalType\":\"struct strings.slice\",\"name\":\"self\",\"type\":\"tuple\"}],\"name\":\"len\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"l\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"_len\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_ptr\",\"type\":\"uint256\"}],\"internalType\":\"struct strings.slice\",\"name\":\"self\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"_len\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_ptr\",\"type\":\"uint256\"}],\"internalType\":\"struct strings.slice\",\"name\":\"rune\",\"type\":\"tuple\"}],\"name\":\"nextRune\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"_len\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_ptr\",\"type\":\"uint256\"}],\"internalType\":\"struct strings.slice\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"_len\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_ptr\",\"type\":\"uint256\"}],\"internalType\":\"struct strings.slice\",\"name\":\"self\",\"type\":\"tuple\"}],\"name\":\"nextRune\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"_len\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_ptr\",\"type\":\"uint256\"}],\"internalType\":\"struct strings.slice\",\"name\":\"ret\",\"type\":\"tuple\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"_len\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_ptr\",\"type\":\"uint256\"}],\"internalType\":\"struct strings.slice\",\"name\":\"self\",\"type\":\"tuple\"}],\"name\":\"ord\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"ret\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"_len\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_ptr\",\"type\":\"uint256\"}],\"internalType\":\"struct strings.slice\",\"name\":\"self\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"_len\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_ptr\",\"type\":\"uint256\"}],\"internalType\":\"struct strings.slice\",\"name\":\"needle\",\"type\":\"tuple\"}],\"name\":\"rfind\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"_len\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_ptr\",\"type\":\"uint256\"}],\"internalType\":\"struct strings.slice\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"_len\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_ptr\",\"type\":\"uint256\"}],\"internalType\":\"struct strings.slice\",\"name\":\"self\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"_len\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_ptr\",\"type\":\"uint256\"}],\"internalType\":\"struct strings.slice\",\"name\":\"needle\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"_len\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_ptr\",\"type\":\"uint256\"}],\"internalType\":\"struct strings.slice\",\"name\":\"token\",\"type\":\"tuple\"}],\"name\":\"rsplit\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"_len\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_ptr\",\"type\":\"uint256\"}],\"internalType\":\"struct strings.slice\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"_len\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_ptr\",\"type\":\"uint256\"}],\"internalType\":\"struct strings.slice\",\"name\":\"self\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"_len\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_ptr\",\"type\":\"uint256\"}],\"internalType\":\"struct strings.slice\",\"name\":\"needle\",\"type\":\"tuple\"}],\"name\":\"rsplit\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"_len\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_ptr\",\"type\":\"uint256\"}],\"internalType\":\"struct strings.slice\",\"name\":\"token\",\"type\":\"tuple\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"_len\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_ptr\",\"type\":\"uint256\"}],\"internalType\":\"struct strings.slice\",\"name\":\"self\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"_len\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_ptr\",\"type\":\"uint256\"}],\"internalType\":\"struct strings.slice\",\"name\":\"needle\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"_len\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_ptr\",\"type\":\"uint256\"}],\"internalType\":\"struct strings.slice\",\"name\":\"token\",\"type\":\"tuple\"}],\"name\":\"split\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"_len\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_ptr\",\"type\":\"uint256\"}],\"internalType\":\"struct strings.slice\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"_len\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_ptr\",\"type\":\"uint256\"}],\"internalType\":\"struct strings.slice\",\"name\":\"self\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"_len\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_ptr\",\"type\":\"uint256\"}],\"internalType\":\"struct strings.slice\",\"name\":\"needle\",\"type\":\"tuple\"}],\"name\":\"split\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"_len\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_ptr\",\"type\":\"uint256\"}],\"internalType\":\"struct strings.slice\",\"name\":\"token\",\"type\":\"tuple\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"_len\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_ptr\",\"type\":\"uint256\"}],\"internalType\":\"struct strings.slice\",\"name\":\"self\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"_len\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_ptr\",\"type\":\"uint256\"}],\"internalType\":\"struct strings.slice\",\"name\":\"needle\",\"type\":\"tuple\"}],\"name\":\"startsWith\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"self\",\"type\":\"string\"}],\"name\":\"toSlice\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"_len\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_ptr\",\"type\":\"uint256\"}],\"internalType\":\"struct strings.slice\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"self\",\"type\":\"bytes32\"}],\"name\":\"toSliceB32\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"_len\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_ptr\",\"type\":\"uint256\"}],\"internalType\":\"struct strings.slice\",\"name\":\"ret\",\"type\":\"tuple\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"_len\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_ptr\",\"type\":\"uint256\"}],\"internalType\":\"struct strings.slice\",\"name\":\"self\",\"type\":\"tuple\"}],\"name\":\"toString\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"_len\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_ptr\",\"type\":\"uint256\"}],\"internalType\":\"struct strings.slice\",\"name\":\"self\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"_len\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_ptr\",\"type\":\"uint256\"}],\"internalType\":\"struct strings.slice\",\"name\":\"needle\",\"type\":\"tuple\"}],\"name\":\"until\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"_len\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_ptr\",\"type\":\"uint256\"}],\"internalType\":\"struct strings.slice\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/strings.sol\":\"strings\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":false,\"runs\":200},\"remappings\":[]},\"sources\":{\"contracts/strings.sol\":{\"content\":\"/*\\n * @title String & slice utility library for Solidity contracts.\\n * @author Nick Johnson <arachnid@notdot.net>\\n *\\n * @dev Functionality in this library is largely implemented using an\\n *      abstraction called a 'slice'. A slice represents a part of a string -\\n *      anything from the entire string to a single character, or even no\\n *      characters at all (a 0-length slice). Since a slice only has to specify\\n *      an offset and a length, copying and manipulating slices is a lot less\\n *      expensive than copying and manipulating the strings they reference.\\n *\\n *      To further reduce gas costs, most functions on slice that need to return\\n *      a slice modify the original one instead of allocating a new one; for\\n *      instance, `s.split(\\\".\\\")` will return the text up to the first '.',\\n *      modifying s to only contain the remainder of the string after the '.'.\\n *      In situations where you do not want to modify the original slice, you\\n *      can make a copy first with `.copy()`, for example:\\n *      `s.copy().split(\\\".\\\")`. Try and avoid using this idiom in loops; since\\n *      Solidity has no memory management, it will result in allocating many\\n *      short-lived slices that are later discarded.\\n *\\n *      Functions that return two slices come in two versions: a non-allocating\\n *      version that takes the second slice as an argument, modifying it in\\n *      place, and an allocating version that allocates and returns the second\\n *      slice; see `nextRune` for example.\\n *\\n *      Functions that have to copy string data will return strings rather than\\n *      slices; these can be cast back to slices for further processing if\\n *      required.\\n *\\n *      For convenience, some functions are provided with non-modifying\\n *      variants that create a new slice and return both; for instance,\\n *      `s.splitNew('.')` leaves s unmodified, and returns two values\\n *      corresponding to the left and right parts of the string.\\n */\\n\\npragma solidity ^0.8.0;\\n\\nlibrary strings {\\n    struct slice {\\n        uint _len;\\n        uint _ptr;\\n    }\\n\\n    function memcpy(uint dest, uint src, uint len) private pure {\\n        // Copy word-length chunks while possible\\n        for(; len >= 32; len -= 32) {\\n            assembly {\\n                mstore(dest, mload(src))\\n            }\\n            dest += 32;\\n            src += 32;\\n        }\\n\\n        // Copy remaining bytes\\n        uint mask = type(uint).max;\\n        if (len > 0) {\\n            mask = 256 ** (32 - len) - 1;\\n        }\\n        assembly {\\n            let srcpart := and(mload(src), not(mask))\\n            let destpart := and(mload(dest), mask)\\n            mstore(dest, or(destpart, srcpart))\\n        }\\n    }\\n\\n    /*\\n     * @dev Returns a slice containing the entire string.\\n     * @param self The string to make a slice from.\\n     * @return A newly allocated slice containing the entire string.\\n     */\\n    function toSlice(string memory self) public pure returns (slice memory) {\\n        uint ptr;\\n        assembly {\\n            ptr := add(self, 0x20)\\n        }\\n        return slice(bytes(self).length, ptr);\\n    }\\n\\n    /*\\n     * @dev Returns the length of a null-terminated bytes32 string.\\n     * @param self The value to find the length of.\\n     * @return The length of the string, from 0 to 32.\\n     */\\n    function len(bytes32 self) public pure returns (uint) {\\n        uint ret;\\n        if (self == 0)\\n            return 0;\\n        if (uint(self) & type(uint128).max == 0) {\\n            ret += 16;\\n            self = bytes32(uint(self) / 0x100000000000000000000000000000000);\\n        }\\n        if (uint(self) & type(uint64).max == 0) {\\n            ret += 8;\\n            self = bytes32(uint(self) / 0x10000000000000000);\\n        }\\n        if (uint(self) & type(uint32).max == 0) {\\n            ret += 4;\\n            self = bytes32(uint(self) / 0x100000000);\\n        }\\n        if (uint(self) & type(uint16).max == 0) {\\n            ret += 2;\\n            self = bytes32(uint(self) / 0x10000);\\n        }\\n        if (uint(self) & type(uint8).max == 0) {\\n            ret += 1;\\n        }\\n        return 32 - ret;\\n    }\\n\\n    /*\\n     * @dev Returns a slice containing the entire bytes32, interpreted as a\\n     *      null-terminated utf-8 string.\\n     * @param self The bytes32 value to convert to a slice.\\n     * @return A new slice containing the value of the input argument up to the\\n     *         first null.\\n     */\\n    function toSliceB32(bytes32 self) public pure returns (slice memory ret) {\\n        // Allocate space for `self` in memory, copy it there, and point ret at it\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(0x40, add(ptr, 0x20))\\n            mstore(ptr, self)\\n            mstore(add(ret, 0x20), ptr)\\n        }\\n        ret._len = len(self);\\n    }\\n\\n    /*\\n     * @dev Returns a new slice containing the same data as the current slice.\\n     * @param self The slice to copy.\\n     * @return A new slice containing the same data as `self`.\\n     */\\n    function copy(slice memory self) public pure returns (slice memory) {\\n        return slice(self._len, self._ptr);\\n    }\\n\\n    /*\\n     * @dev Copies a slice to a new string.\\n     * @param self The slice to copy.\\n     * @return A newly allocated string containing the slice's text.\\n     */\\n    function toString(slice memory self) public pure returns (string memory) {\\n        string memory ret = new string(self._len);\\n        uint retptr;\\n        assembly { retptr := add(ret, 32) }\\n\\n        memcpy(retptr, self._ptr, self._len);\\n        return ret;\\n    }\\n\\n    /*\\n     * @dev Returns the length in runes of the slice. Note that this operation\\n     *      takes time proportional to the length of the slice; avoid using it\\n     *      in loops, and call `slice.empty()` if you only need to know whether\\n     *      the slice is empty or not.\\n     * @param self The slice to operate on.\\n     * @return The length of the slice in runes.\\n     */\\n    function len(slice memory self) public pure returns (uint l) {\\n        // Starting at ptr-31 means the LSB will be the byte we care about\\n        uint ptr = self._ptr - 31;\\n        uint end = ptr + self._len;\\n        for (l = 0; ptr < end; l++) {\\n            uint8 b;\\n            assembly { b := and(mload(ptr), 0xFF) }\\n            if (b < 0x80) {\\n                ptr += 1;\\n            } else if(b < 0xE0) {\\n                ptr += 2;\\n            } else if(b < 0xF0) {\\n                ptr += 3;\\n            } else if(b < 0xF8) {\\n                ptr += 4;\\n            } else if(b < 0xFC) {\\n                ptr += 5;\\n            } else {\\n                ptr += 6;\\n            }\\n        }\\n    }\\n\\n    /*\\n     * @dev Returns true if the slice is empty (has a length of 0).\\n     * @param self The slice to operate on.\\n     * @return True if the slice is empty, False otherwise.\\n     */\\n    function empty(slice memory self) public pure returns (bool) {\\n        return self._len == 0;\\n    }\\n\\n    /*\\n     * @dev Returns a positive number if `other` comes lexicographically after\\n     *      `self`, a negative number if it comes before, or zero if the\\n     *      contents of the two slices are equal. Comparison is done per-rune,\\n     *      on unicode codepoints.\\n     * @param self The first slice to compare.\\n     * @param other The second slice to compare.\\n     * @return The result of the comparison.\\n     */\\n    function compare(slice memory self, slice memory other) public pure returns (int) {\\n        uint shortest = self._len;\\n        if (other._len < self._len)\\n            shortest = other._len;\\n\\n        uint selfptr = self._ptr;\\n        uint otherptr = other._ptr;\\n        for (uint idx = 0; idx < shortest; idx += 32) {\\n            uint a;\\n            uint b;\\n            assembly {\\n                a := mload(selfptr)\\n                b := mload(otherptr)\\n            }\\n            if (a != b) {\\n                // Mask out irrelevant bytes and check again\\n                uint mask = type(uint).max; // 0xffff...\\n                if(shortest < 32) {\\n                  mask = ~(2 ** (8 * (32 - shortest + idx)) - 1);\\n                }\\n                unchecked {\\n                    uint diff = (a & mask) - (b & mask);\\n                    if (diff != 0)\\n                        return int(diff);\\n                }\\n            }\\n            selfptr += 32;\\n            otherptr += 32;\\n        }\\n        return int(self._len) - int(other._len);\\n    }\\n\\n    /*\\n     * @dev Returns true if the two slices contain the same text.\\n     * @param self The first slice to compare.\\n     * @param self The second slice to compare.\\n     * @return True if the slices are equal, false otherwise.\\n     */\\n    function equals(slice memory self, slice memory other) public pure returns (bool) {\\n        return compare(self, other) == 0;\\n    }\\n\\n    /*\\n     * @dev Extracts the first rune in the slice into `rune`, advancing the\\n     *      slice to point to the next rune and returning `self`.\\n     * @param self The slice to operate on.\\n     * @param rune The slice that will contain the first rune.\\n     * @return `rune`.\\n     */\\n    function nextRune(slice memory self, slice memory rune) public pure returns (slice memory) {\\n        rune._ptr = self._ptr;\\n\\n        if (self._len == 0) {\\n            rune._len = 0;\\n            return rune;\\n        }\\n\\n        uint l;\\n        uint b;\\n        // Load the first byte of the rune into the LSBs of b\\n        assembly { b := and(mload(sub(mload(add(self, 32)), 31)), 0xFF) }\\n        if (b < 0x80) {\\n            l = 1;\\n        } else if(b < 0xE0) {\\n            l = 2;\\n        } else if(b < 0xF0) {\\n            l = 3;\\n        } else {\\n            l = 4;\\n        }\\n\\n        // Check for truncated codepoints\\n        if (l > self._len) {\\n            rune._len = self._len;\\n            self._ptr += self._len;\\n            self._len = 0;\\n            return rune;\\n        }\\n\\n        self._ptr += l;\\n        self._len -= l;\\n        rune._len = l;\\n        return rune;\\n    }\\n\\n    /*\\n     * @dev Returns the first rune in the slice, advancing the slice to point\\n     *      to the next rune.\\n     * @param self The slice to operate on.\\n     * @return A slice containing only the first rune from `self`.\\n     */\\n    function nextRune(slice memory self) public pure returns (slice memory ret) {\\n        nextRune(self, ret);\\n    }\\n\\n    /*\\n     * @dev Returns the number of the first codepoint in the slice.\\n     * @param self The slice to operate on.\\n     * @return The number of the first codepoint in the slice.\\n     */\\n    function ord(slice memory self) public pure returns (uint ret) {\\n        if (self._len == 0) {\\n            return 0;\\n        }\\n\\n        uint word;\\n        uint length;\\n        uint divisor = 2 ** 248;\\n\\n        // Load the rune into the MSBs of b\\n        assembly { word:= mload(mload(add(self, 32))) }\\n        uint b = word / divisor;\\n        if (b < 0x80) {\\n            ret = b;\\n            length = 1;\\n        } else if(b < 0xE0) {\\n            ret = b & 0x1F;\\n            length = 2;\\n        } else if(b < 0xF0) {\\n            ret = b & 0x0F;\\n            length = 3;\\n        } else {\\n            ret = b & 0x07;\\n            length = 4;\\n        }\\n\\n        // Check for truncated codepoints\\n        if (length > self._len) {\\n            return 0;\\n        }\\n\\n        for (uint i = 1; i < length; i++) {\\n            divisor = divisor / 256;\\n            b = (word / divisor) & 0xFF;\\n            if (b & 0xC0 != 0x80) {\\n                // Invalid UTF-8 sequence\\n                return 0;\\n            }\\n            ret = (ret * 64) | (b & 0x3F);\\n        }\\n\\n        return ret;\\n    }\\n\\n    /*\\n     * @dev Returns the keccak-256 hash of the slice.\\n     * @param self The slice to hash.\\n     * @return The hash of the slice.\\n     */\\n    function keccak(slice memory self) public pure returns (bytes32 ret) {\\n        assembly {\\n            ret := keccak256(mload(add(self, 32)), mload(self))\\n        }\\n    }\\n\\n    /*\\n     * @dev Returns true if `self` starts with `needle`.\\n     * @param self The slice to operate on.\\n     * @param needle The slice to search for.\\n     * @return True if the slice starts with the provided text, false otherwise.\\n     */\\n    function startsWith(slice memory self, slice memory needle) public pure returns (bool) {\\n        if (self._len < needle._len) {\\n            return false;\\n        }\\n\\n        if (self._ptr == needle._ptr) {\\n            return true;\\n        }\\n\\n        bool equal;\\n        assembly {\\n            let length := mload(needle)\\n            let selfptr := mload(add(self, 0x20))\\n            let needleptr := mload(add(needle, 0x20))\\n            equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\\n        }\\n        return equal;\\n    }\\n\\n    /*\\n     * @dev If `self` starts with `needle`, `needle` is removed from the\\n     *      beginning of `self`. Otherwise, `self` is unmodified.\\n     * @param self The slice to operate on.\\n     * @param needle The slice to search for.\\n     * @return `self`\\n     */\\n    function beyond(slice memory self, slice memory needle) public pure returns (slice memory) {\\n        if (self._len < needle._len) {\\n            return self;\\n        }\\n\\n        bool equal = true;\\n        if (self._ptr != needle._ptr) {\\n            assembly {\\n                let length := mload(needle)\\n                let selfptr := mload(add(self, 0x20))\\n                let needleptr := mload(add(needle, 0x20))\\n                equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\\n            }\\n        }\\n\\n        if (equal) {\\n            self._len -= needle._len;\\n            self._ptr += needle._len;\\n        }\\n\\n        return self;\\n    }\\n\\n    /*\\n     * @dev Returns true if the slice ends with `needle`.\\n     * @param self The slice to operate on.\\n     * @param needle The slice to search for.\\n     * @return True if the slice starts with the provided text, false otherwise.\\n     */\\n    function endsWith(slice memory self, slice memory needle) public pure returns (bool) {\\n        if (self._len < needle._len) {\\n            return false;\\n        }\\n\\n        uint selfptr = self._ptr + self._len - needle._len;\\n\\n        if (selfptr == needle._ptr) {\\n            return true;\\n        }\\n\\n        bool equal;\\n        assembly {\\n            let length := mload(needle)\\n            let needleptr := mload(add(needle, 0x20))\\n            equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\\n        }\\n\\n        return equal;\\n    }\\n\\n    /*\\n     * @dev If `self` ends with `needle`, `needle` is removed from the\\n     *      end of `self`. Otherwise, `self` is unmodified.\\n     * @param self The slice to operate on.\\n     * @param needle The slice to search for.\\n     * @return `self`\\n     */\\n    function until(slice memory self, slice memory needle) public pure returns (slice memory) {\\n        if (self._len < needle._len) {\\n            return self;\\n        }\\n\\n        uint selfptr = self._ptr + self._len - needle._len;\\n        bool equal = true;\\n        if (selfptr != needle._ptr) {\\n            assembly {\\n                let length := mload(needle)\\n                let needleptr := mload(add(needle, 0x20))\\n                equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\\n            }\\n        }\\n\\n        if (equal) {\\n            self._len -= needle._len;\\n        }\\n\\n        return self;\\n    }\\n\\n    // Returns the memory address of the first byte of the first occurrence of\\n    // `needle` in `self`, or the first byte after `self` if not found.\\n    function findPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) {\\n        uint ptr = selfptr;\\n        uint idx;\\n\\n        if (needlelen <= selflen) {\\n            if (needlelen <= 32) {\\n                bytes32 mask;\\n                if (needlelen > 0) {\\n                    mask = bytes32(~(2 ** (8 * (32 - needlelen)) - 1));\\n                }\\n\\n                bytes32 needledata;\\n                assembly { needledata := and(mload(needleptr), mask) }\\n\\n                uint end = selfptr + selflen - needlelen;\\n                bytes32 ptrdata;\\n                assembly { ptrdata := and(mload(ptr), mask) }\\n\\n                while (ptrdata != needledata) {\\n                    if (ptr >= end)\\n                        return selfptr + selflen;\\n                    ptr++;\\n                    assembly { ptrdata := and(mload(ptr), mask) }\\n                }\\n                return ptr;\\n            } else {\\n                // For long needles, use hashing\\n                bytes32 hash;\\n                assembly { hash := keccak256(needleptr, needlelen) }\\n\\n                for (idx = 0; idx <= selflen - needlelen; idx++) {\\n                    bytes32 testHash;\\n                    assembly { testHash := keccak256(ptr, needlelen) }\\n                    if (hash == testHash)\\n                        return ptr;\\n                    ptr += 1;\\n                }\\n            }\\n        }\\n        return selfptr + selflen;\\n    }\\n\\n    // Returns the memory address of the first byte after the last occurrence of\\n    // `needle` in `self`, or the address of `self` if not found.\\n    function rfindPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) {\\n        uint ptr;\\n\\n        if (needlelen <= selflen) {\\n            if (needlelen <= 32) {\\n                bytes32 mask;\\n                if (needlelen > 0) {\\n                    mask = bytes32(~(2 ** (8 * (32 - needlelen)) - 1));\\n                }\\n\\n                bytes32 needledata;\\n                assembly { needledata := and(mload(needleptr), mask) }\\n\\n                ptr = selfptr + selflen - needlelen;\\n                bytes32 ptrdata;\\n                assembly { ptrdata := and(mload(ptr), mask) }\\n\\n                while (ptrdata != needledata) {\\n                    if (ptr <= selfptr)\\n                        return selfptr;\\n                    ptr--;\\n                    assembly { ptrdata := and(mload(ptr), mask) }\\n                }\\n                return ptr + needlelen;\\n            } else {\\n                // For long needles, use hashing\\n                bytes32 hash;\\n                assembly { hash := keccak256(needleptr, needlelen) }\\n                ptr = selfptr + (selflen - needlelen);\\n                while (ptr >= selfptr) {\\n                    bytes32 testHash;\\n                    assembly { testHash := keccak256(ptr, needlelen) }\\n                    if (hash == testHash)\\n                        return ptr + needlelen;\\n                    ptr -= 1;\\n                }\\n            }\\n        }\\n        return selfptr;\\n    }\\n\\n    /*\\n     * @dev Modifies `self` to contain everything from the first occurrence of\\n     *      `needle` to the end of the slice. `self` is set to the empty slice\\n     *      if `needle` is not found.\\n     * @param self The slice to search and modify.\\n     * @param needle The text to search for.\\n     * @return `self`.\\n     */\\n    function find(slice memory self, slice memory needle) public pure returns (slice memory) {\\n        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr);\\n        self._len -= ptr - self._ptr;\\n        self._ptr = ptr;\\n        return self;\\n    }\\n\\n    /*\\n     * @dev Modifies `self` to contain the part of the string from the start of\\n     *      `self` to the end of the first occurrence of `needle`. If `needle`\\n     *      is not found, `self` is set to the empty slice.\\n     * @param self The slice to search and modify.\\n     * @param needle The text to search for.\\n     * @return `self`.\\n     */\\n    function rfind(slice memory self, slice memory needle) public pure returns (slice memory) {\\n        uint ptr = rfindPtr(self._len, self._ptr, needle._len, needle._ptr);\\n        self._len = ptr - self._ptr;\\n        return self;\\n    }\\n\\n    /*\\n     * @dev Splits the slice, setting `self` to everything after the first\\n     *      occurrence of `needle`, and `token` to everything before it. If\\n     *      `needle` does not occur in `self`, `self` is set to the empty slice,\\n     *      and `token` is set to the entirety of `self`.\\n     * @param self The slice to split.\\n     * @param needle The text to search for in `self`.\\n     * @param token An output parameter to which the first token is written.\\n     * @return `token`.\\n     */\\n    function split(slice memory self, slice memory needle, slice memory token) public pure returns (slice memory) {\\n        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr);\\n        token._ptr = self._ptr;\\n        token._len = ptr - self._ptr;\\n        if (ptr == self._ptr + self._len) {\\n            // Not found\\n            self._len = 0;\\n        } else {\\n            self._len -= token._len + needle._len;\\n            self._ptr = ptr + needle._len;\\n        }\\n        return token;\\n    }\\n\\n    /*\\n     * @dev Splits the slice, setting `self` to everything after the first\\n     *      occurrence of `needle`, and returning everything before it. If\\n     *      `needle` does not occur in `self`, `self` is set to the empty slice,\\n     *      and the entirety of `self` is returned.\\n     * @param self The slice to split.\\n     * @param needle The text to search for in `self`.\\n     * @return The part of `self` up to the first occurrence of `delim`.\\n     */\\n    function split(slice memory self, slice memory needle) public pure returns (slice memory token) {\\n        split(self, needle, token);\\n    }\\n\\n    /*\\n     * @dev Splits the slice, setting `self` to everything before the last\\n     *      occurrence of `needle`, and `token` to everything after it. If\\n     *      `needle` does not occur in `self`, `self` is set to the empty slice,\\n     *      and `token` is set to the entirety of `self`.\\n     * @param self The slice to split.\\n     * @param needle The text to search for in `self`.\\n     * @param token An output parameter to which the first token is written.\\n     * @return `token`.\\n     */\\n    function rsplit(slice memory self, slice memory needle, slice memory token) public pure returns (slice memory) {\\n        uint ptr = rfindPtr(self._len, self._ptr, needle._len, needle._ptr);\\n        token._ptr = ptr;\\n        token._len = self._len - (ptr - self._ptr);\\n        if (ptr == self._ptr) {\\n            // Not found\\n            self._len = 0;\\n        } else {\\n            self._len -= token._len + needle._len;\\n        }\\n        return token;\\n    }\\n\\n    /*\\n     * @dev Splits the slice, setting `self` to everything before the last\\n     *      occurrence of `needle`, and returning everything after it. If\\n     *      `needle` does not occur in `self`, `self` is set to the empty slice,\\n     *      and the entirety of `self` is returned.\\n     * @param self The slice to split.\\n     * @param needle The text to search for in `self`.\\n     * @return The part of `self` after the last occurrence of `delim`.\\n     */\\n    function rsplit(slice memory self, slice memory needle) public pure returns (slice memory token) {\\n        rsplit(self, needle, token);\\n    }\\n\\n    /*\\n     * @dev Counts the number of nonoverlapping occurrences of `needle` in `self`.\\n     * @param self The slice to search.\\n     * @param needle The text to search for in `self`.\\n     * @return The number of occurrences of `needle` found in `self`.\\n     */\\n    function count(slice memory self, slice memory needle) public pure returns (uint cnt) {\\n        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr) + needle._len;\\n        while (ptr <= self._ptr + self._len) {\\n            cnt++;\\n            ptr = findPtr(self._len - (ptr - self._ptr), ptr, needle._len, needle._ptr) + needle._len;\\n        }\\n    }\\n\\n    /*\\n     * @dev Returns True if `self` contains `needle`.\\n     * @param self The slice to search.\\n     * @param needle The text to search for in `self`.\\n     * @return True if `needle` is found in `self`, false otherwise.\\n     */\\n    function contains(slice memory self, slice memory needle) public pure returns (bool) {\\n        return rfindPtr(self._len, self._ptr, needle._len, needle._ptr) != self._ptr;\\n    }\\n\\n    /*\\n     * @dev Returns a newly allocated string containing the concatenation of\\n     *      `self` and `other`.\\n     * @param self The first slice to concatenate.\\n     * @param other The second slice to concatenate.\\n     * @return The concatenation of the two strings.\\n     */\\n    function concat(slice memory self, slice memory other) public pure returns (string memory) {\\n        string memory ret = new string(self._len + other._len);\\n        uint retptr;\\n        assembly { retptr := add(ret, 32) }\\n        memcpy(retptr, self._ptr, self._len);\\n        memcpy(retptr + self._len, other._ptr, other._len);\\n        return ret;\\n    }\\n\\n    /*\\n     * @dev Joins an array of slices, using `self` as a delimiter, returning a\\n     *      newly allocated string.\\n     * @param self The delimiter to use.\\n     * @param parts A list of slices to join.\\n     * @return A newly allocated string containing all the slices in `parts`,\\n     *         joined with `self`.\\n     */\\n    function join(slice memory self, slice[] memory parts) public pure returns (string memory) {\\n        if (parts.length == 0)\\n            return \\\"\\\";\\n\\n        uint length = self._len * (parts.length - 1);\\n        for(uint i = 0; i < parts.length; i++)\\n            length += parts[i]._len;\\n\\n        string memory ret = new string(length);\\n        uint retptr;\\n        assembly { retptr := add(ret, 32) }\\n\\n        for(uint i = 0; i < parts.length; i++) {\\n            memcpy(retptr, parts[i]._ptr, parts[i]._len);\\n            retptr += parts[i]._len;\\n            if (i < parts.length - 1) {\\n                memcpy(retptr, self._ptr, self._len);\\n                retptr += self._len;\\n            }\\n        }\\n\\n        return ret;\\n    }\\n}\",\"keccak256\":\"0x011e18dadd931bc104072ce318520998933a09e7729e87938f54476578e986e0\"}},\"version\":1}",
  "bytecode": "0x612432610053600b82828239805160001a607314610046577f4e487b7100000000000000000000000000000000000000000000000000000000600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600436106101b35760003560e01c806373abf5f911610103578063ba547d26116100a1578063e687c3e91161007b578063e687c3e914610608578063f5f10b6514610638578063fb0c60a114610668578063fe71659c14610698576101b3565b8063ba547d2614610578578063c3a9b1f3146105a8578063def4d178146105d8576101b3565b806387f39b92116100dd57806387f39b92146104b85780638a7b032c146104e857806393ea9c1414610518578063afed762b14610548576101b3565b806373abf5f91461042857806375ad988d146104585780637a92f80f14610488576101b3565b806333fc12a9116101705780634a5f55481161014a5780634a5f5548146103685780634b5e282a146103985780634d5ed07a146103c8578063668c6738146103f8576101b3565b806333fc12a9146102d857806343ec3f3814610308578063486299a914610338576101b3565b80630a33d3da146101b8578063166c4b85146101e85780631c52e2fc146102185780631f8e60581461024857806321512c92146102785780632b8a41ef146102a8575b600080fd5b6101d260048036038101906101cd9190611bf7565b6106c8565b6040516101df9190611dcd565b60405180910390f35b61020260048036038101906101fd9190611b8d565b6106d9565b60405161020f9190611e40565b60405180910390f35b610232600480360381019061022d9190611c74565b610838565b60405161023f9190611e25565b60405180910390f35b610262600480360381019061025d9190611cb0565b610950565b60405161026f9190611e25565b60405180910390f35b610292600480360381019061028d9190611c74565b6109fe565b60405161029f9190611db2565b60405180910390f35b6102c260048036038101906102bd9190611c74565b610a2b565b6040516102cf9190611db2565b60405180910390f35b6102f260048036038101906102ed9190611c74565b610aa3565b6040516102ff9190611e25565b60405180910390f35b610322600480360381019061031d9190611b8d565b610abd565b60405161032f9190611e25565b60405180910390f35b610352600480360381019061034d9190611c74565b610af0565b60405161035f9190611e40565b60405180910390f35b610382600480360381019061037d9190611bf7565b610b98565b60405161038f9190611e25565b60405180910390f35b6103b260048036038101906103ad9190611cb0565b610bb0565b6040516103bf9190611e25565b60405180910390f35b6103e260048036038101906103dd9190611c74565b610c7b565b6040516103ef9190611db2565b60405180910390f35b610412600480360381019061040d9190611c20565b610c91565b60405161041f9190611e03565b60405180910390f35b610442600480360381019061043d9190611c74565b610f13565b60405161044f9190611e25565b60405180910390f35b610472600480360381019061046d9190611c74565b610fad565b60405161047f9190611db2565b60405180910390f35b6104a2600480360381019061049d9190611bf7565b611006565b6040516104af9190611db2565b60405180910390f35b6104d260048036038101906104cd9190611c74565b611016565b6040516104df9190611e03565b60405180910390f35b61050260048036038101906104fd9190611bf7565b6110ea565b60405161050f9190611e03565b60405180910390f35b610532600480360381019061052d9190611c74565b61118c565b60405161053f9190611e25565b60405180910390f35b610562600480360381019061055d9190611bb6565b6111a6565b60405161056f9190611e25565b60405180910390f35b610592600480360381019061058d9190611c74565b6111d4565b60405161059f9190611e25565b60405180910390f35b6105c260048036038101906105bd9190611bf7565b611238565b6040516105cf9190611e40565b60405180910390f35b6105f260048036038101906105ed9190611c74565b611347565b6040516105ff9190611e25565b60405180910390f35b610622600480360381019061061d9190611c74565b6113e2565b60405161062f9190611de8565b60405180910390f35b610652600480360381019061064d9190611bf7565b61151c565b60405161065f9190611e25565b60405180910390f35b610682600480360381019061067d9190611c74565b611548565b60405161068f9190611e25565b60405180910390f35b6106b260048036038101906106ad9190611bf7565b611593565b6040516106bf9190611e40565b60405180910390f35b600081516020830151209050919050565b6000806000801b8314156106f1576000915050610833565b60006fffffffffffffffffffffffffffffffff80168460001c1614156107465760108161071e9190611ef9565b90507001000000000000000000000000000000008360001c6107409190611f4f565b60001b92505b600067ffffffffffffffff80168460001c16141561078b5760088161076b9190611ef9565b9050680100000000000000008360001c6107859190611f4f565b60001b92505b600063ffffffff80168460001c1614156107c8576004816107ac9190611ef9565b90506401000000008360001c6107c29190611f4f565b60001b92505b600061ffff80168460001c161415610801576002816107e79190611ef9565b9050620100008360001c6107fb9190611f4f565b60001b92505b600060ff80168460001c1614156108225760018161081f9190611ef9565b90505b80602061082f91906121df565b9150505b919050565b6108406119ff565b826020015182602001818152505060008360000151141561086e57600082600001818152505081905061094a565b60008060ff601f60208701510351169050608081101561089157600191506108bc565b60e08110156108a357600291506108bb565b60f08110156108b557600391506108ba565b600491505b5b5b84600001518211156109085784600001518460000181815250508460000151856020018181516108ec9190611ef9565b915081815250506000856000018181525050839250505061094a565b818560200181815161091a9190611ef9565b91508181525050818560000181815161093391906121df565b915081815250508184600001818152505083925050505b92915050565b6109586119ff565b600061097685600001518660200151866000015187602001516116d0565b90508083602001818152505084602001518161099291906121df565b85600001516109a191906121df565b83600001818152505084602001518114156109c65760008560000181815250506109f3565b836000015183600001516109da9190611ef9565b856000018181516109eb91906121df565b915081815250505b829150509392505050565b60008260200151610a2184600001518560200151856000015186602001516116d0565b1415905092915050565b6000816000015183600001511015610a465760009050610a9d565b6000826000015184600001518560200151610a619190611ef9565b610a6b91906121df565b90508260200151811415610a83576001915050610a9d565b600083516020850151818120828520149250505080925050505b92915050565b610aab6119ff565b610ab6838383610950565b5092915050565b610ac56119ff565b6040516020810160405282815280602083015250610ae2826106d9565b816000018181525050919050565b6000808260000151610b148560000151866020015186600001518760200151611809565b610b1e9190611ef9565b90505b83600001518460200151610b359190611ef9565b8111610b91578180610b46906122da565b9250508260000151610b80856020015183610b6191906121df565b8660000151610b7091906121df565b8386600001518760200151611809565b610b8a9190611ef9565b9050610b21565b5092915050565b610ba06119ff565b610baa8282610838565b50919050565b610bb86119ff565b6000610bd68560000151866020015186600001518760200151611809565b90508460200151836020018181525050846020015181610bf691906121df565b83600001818152505084600001518560200151610c139190611ef9565b811415610c2a576000856000018181525050610c70565b83600001518360000151610c3e9190611ef9565b85600001818151610c4f91906121df565b91508181525050836000015181610c669190611ef9565b8560200181815250505b829150509392505050565b600080610c8884846113e2565b14905092915050565b6060600082511415610cb457604051806020016040528060008152509050610f0d565b600060018351610cc491906121df565b8460000151610cd391906120f1565b905060005b8351811015610d4657838181518110610d1a577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b60200260200101516000015182610d319190611ef9565b91508080610d3e906122da565b915050610cd8565b5060008167ffffffffffffffff811115610d89577f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6040519080825280601f01601f191660200182016040528015610dbb5781602001600182028036833780820191505090505b509050600060208201905060005b8551811015610f0557610e6582878381518110610e0f577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b602002602001015160200151888481518110610e54577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b602002602001015160000151611953565b858181518110610e9e577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b60200260200101516000015182610eb59190611ef9565b915060018651610ec591906121df565b811015610ef257610edf8288602001518960000151611953565b866000015182610eef9190611ef9565b91505b8080610efd906122da565b915050610dc9565b508193505050505b92915050565b610f1b6119ff565b816000015183600001511015610f3357829050610fa7565b6000600190508260200151846020015114610f61578251602085015160208501518281208383201493505050505b8015610fa257826000015184600001818151610f7d91906121df565b91508181525050826000015184602001818151610f9a9190611ef9565b915081815250505b839150505b92915050565b6000816000015183600001511015610fc85760009050611000565b816020015183602001511415610fe15760019050611000565b6000825160208501516020850151828120838320149350505050809150505b92915050565b6000808260000151149050919050565b606060008260000151846000015161102e9190611ef9565b67ffffffffffffffff81111561106d577f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6040519080825280601f01601f19166020018201604052801561109f5781602001600182028036833780820191505090505b50905060006020820190506110bd8186602001518760000151611953565b6110df8560000151826110d09190611ef9565b85602001518660000151611953565b819250505092915050565b60606000826000015167ffffffffffffffff811115611132577f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6040519080825280601f01601f1916602001820160405280156111645781602001600182028036833780820191505090505b50905060006020820190506111828185602001518660000151611953565b8192505050919050565b6111946119ff565b61119f838383610bb0565b5092915050565b6111ae6119ff565b600060208301905060405180604001604052808451815260200182815250915050919050565b6111dc6119ff565b60006111fa8460000151856020015185600001518660200151611809565b905083602001518161120c91906121df565b8460000181815161121d91906121df565b91508181525050808460200181815250508391505092915050565b600080601f836020015161124c91906121df565b905060008360000151826112609190611ef9565b9050600092505b8082101561134057600060ff835116905060808160ff161015611298576001836112919190611ef9565b925061132c565b60e08160ff1610156112b8576002836112b19190611ef9565b925061132b565b60f08160ff1610156112d8576003836112d19190611ef9565b925061132a565b60f88160ff1610156112f8576004836112f19190611ef9565b9250611329565b60fc8160ff161015611318576005836113119190611ef9565b9250611328565b6006836113259190611ef9565b92505b5b5b5b5b508280611338906122da565b935050611267565b5050919050565b61134f6119ff565b816000015183600001511015611367578290506113dc565b60008260000151846000015185602001516113829190611ef9565b61138c91906121df565b9050600060019050836020015182146113b2578351602085015181812082852014925050505b80156113d6578360000151856000018181516113ce91906121df565b915081815250505b84925050505b92915050565b6000808360000151905083600001518360000151101561140457826000015190505b60008460200151905060008460200151905060005b838110156114fb5760008084519150835190508082146114c75760007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff905060208710156114a15760018488602061147191906121df565b61147b9190611ef9565b600861148791906120f1565b60026114939190611fd3565b61149d91906121df565b1990505b6000818316828516039050600081146114c4578098505050505050505050611516565b50505b6020856114d49190611ef9565b94506020846114e39190611ef9565b935050506020816114f49190611ef9565b9050611419565b5084600001518660000151611510919061214b565b93505050505b92915050565b6115246119ff565b60405180604001604052808360000151815260200183602001518152509050919050565b6115506119ff565b600061156e84600001518560200151856000015186602001516116d0565b905083602001518161158091906121df565b8460000181815250508391505092915050565b600080826000015114156115aa57600090506116cb565b60008060007f010000000000000000000000000000000000000000000000000000000000000090506020850151519250600081846115e89190611f4f565b905060808110156115ff578094506001925061163c565b60e081101561161757601f811694506002925061163b565b60f081101561162f57600f811694506003925061163a565b600781169450600492505b5b5b85600001518311156116555760009450505050506116cb565b6000600190505b838110156116c557610100836116729190611f4f565b925060ff83866116829190611f4f565b169150608060c083161461169e576000955050505050506116cb565b603f82166040876116af91906120f1565b17955080806116bd906122da565b91505061165c565b50505050505b919050565b6000808584116117fc5760208411611798576000808511156117245760018560206116fb91906121df565b600861170791906120f1565b60026117139190611fd3565b61171d91906121df565b1960001b90505b60008185511690508588886117399190611ef9565b61174391906121df565b925060008284511690505b818114611781578784116117685787945050505050611801565b83806117739061227f565b94505082845116905061174e565b868461178d9190611ef9565b945050505050611801565b6000848420905084876117ab91906121df565b866117b69190611ef9565b91505b8582106117fa5760008583209050808214156117e55785836117db9190611ef9565b9350505050611801565b6001836117f291906121df565b9250506117b9565b505b849150505b949350505050565b600080849050600086851161193a57602085116118dc5760008086111561186257600186602061183991906121df565b600861184591906120f1565b60026118519190611fd3565b61185b91906121df565b1960001b90505b60008186511690506000878a8a6118799190611ef9565b61188391906121df565b905060008386511690505b8281146118ce578186106118b5578a8a6118a89190611ef9565b965050505050505061194b565b85806118c0906122da565b96505083865116905061188e565b85965050505050505061194b565b60008585209050600091505b85886118f491906121df565b8211611938576000868420905080821415611915578394505050505061194b565b6001846119229190611ef9565b9350508180611930906122da565b9250506118e8565b505b86866119469190611ef9565b925050505b949350505050565b5b60208110611992578151835260208361196d9190611ef9565b925060208261197c9190611ef9565b915060208161198b91906121df565b9050611954565b60007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff905060008211156119e95760018260206119cf91906121df565b6101006119dc9190611fd3565b6119e691906121df565b90505b8019835116818551168181178652505050505050565b604051806040016040528060008152602001600081525090565b6000611a2c611a2784611e80565b611e5b565b90508083825260208201905082856040860282011115611a4b57600080fd5b60005b85811015611a7b5781611a618882611b2c565b845260208401935060408301925050600181019050611a4e565b5050509392505050565b6000611a98611a9384611eac565b611e5b565b905082815260208101848484011115611ab057600080fd5b611abb84828561223d565b509392505050565b600082601f830112611ad457600080fd5b8135611ae4848260208601611a19565b91505092915050565b600081359050611afc816123ce565b92915050565b600082601f830112611b1357600080fd5b8135611b23848260208601611a85565b91505092915050565b600060408284031215611b3e57600080fd5b611b486040611e5b565b90506000611b5884828501611b78565b6000830152506020611b6c84828501611b78565b60208301525092915050565b600081359050611b87816123e5565b92915050565b600060208284031215611b9f57600080fd5b6000611bad84828501611aed565b91505092915050565b600060208284031215611bc857600080fd5b600082013567ffffffffffffffff811115611be257600080fd5b611bee84828501611b02565b91505092915050565b600060408284031215611c0957600080fd5b6000611c1784828501611b2c565b91505092915050565b60008060608385031215611c3357600080fd5b6000611c4185828601611b2c565b925050604083013567ffffffffffffffff811115611c5e57600080fd5b611c6a85828601611ac3565b9150509250929050565b60008060808385031215611c8757600080fd5b6000611c9585828601611b2c565b9250506040611ca685828601611b2c565b9150509250929050565b600080600060c08486031215611cc557600080fd5b6000611cd386828701611b2c565b9350506040611ce486828701611b2c565b9250506080611cf586828701611b2c565b9150509250925092565b611d0881612213565b82525050565b611d178161221f565b82525050565b611d2681612229565b82525050565b6000611d3782611edd565b611d418185611ee8565b9350611d5181856020860161224c565b611d5a816123b0565b840191505092915050565b604082016000820151611d7b6000850182611da3565b506020820151611d8e6020850182611da3565b50505050565b611d9d81612233565b82525050565b611dac81612233565b82525050565b6000602082019050611dc76000830184611cff565b92915050565b6000602082019050611de26000830184611d0e565b92915050565b6000602082019050611dfd6000830184611d1d565b92915050565b60006020820190508181036000830152611e1d8184611d2c565b905092915050565b6000604082019050611e3a6000830184611d65565b92915050565b6000602082019050611e556000830184611d94565b92915050565b6000611e65611e76565b9050611e7182826122a9565b919050565b6000604051905090565b600067ffffffffffffffff821115611e9b57611e9a612381565b5b602082029050602081019050919050565b600067ffffffffffffffff821115611ec757611ec6612381565b5b611ed0826123b0565b9050602081019050919050565b600081519050919050565b600082825260208201905092915050565b6000611f0482612233565b9150611f0f83612233565b9250827fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff03821115611f4457611f43612323565b5b828201905092915050565b6000611f5a82612233565b9150611f6583612233565b925082611f7557611f74612352565b5b828204905092915050565b6000808291508390505b6001851115611fca57808604811115611fa657611fa5612323565b5b6001851615611fb55780820291505b8081029050611fc3856123c1565b9450611f8a565b94509492505050565b6000611fde82612233565b9150611fe983612233565b92506120167fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff848461201e565b905092915050565b60008261202e57600190506120ea565b8161203c57600090506120ea565b8160018114612052576002811461205c5761208b565b60019150506120ea565b60ff84111561206e5761206d612323565b5b8360020a91508482111561208557612084612323565b5b506120ea565b5060208310610133831016604e8410600b84101617156120c05782820a9050838111156120bb576120ba612323565b5b6120ea565b6120cd8484846001611f80565b925090508184048111156120e4576120e3612323565b5b81810290505b9392505050565b60006120fc82612233565b915061210783612233565b9250817fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff04831182151516156121405761213f612323565b5b828202905092915050565b600061215682612229565b915061216183612229565b9250827f80000000000000000000000000000000000000000000000000000000000000000182126000841215161561219c5761219b612323565b5b827f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0182136000841216156121d4576121d3612323565b5b828203905092915050565b60006121ea82612233565b91506121f583612233565b92508282101561220857612207612323565b5b828203905092915050565b60008115159050919050565b6000819050919050565b6000819050919050565b6000819050919050565b82818337600083830152505050565b60005b8381101561226a57808201518184015260208101905061224f565b83811115612279576000848401525b50505050565b600061228a82612233565b9150600082141561229e5761229d612323565b5b600182039050919050565b6122b2826123b0565b810181811067ffffffffffffffff821117156122d1576122d0612381565b5b80604052505050565b60006122e582612233565b91507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff82141561231857612317612323565b5b600182019050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6000601f19601f8301169050919050565b60008160011c9050919050565b6123d78161221f565b81146123e257600080fd5b50565b6123ee81612233565b81146123f957600080fd5b5056fea26469706673582212203544f9a906fe3caa53c25c4ddf7fd4886bc47f553c76f88bd925df9492795aeb64736f6c63430008040033",
  "deployedBytecode": "0x73000000000000000000000000000000000000000030146080604052600436106101b35760003560e01c806373abf5f911610103578063ba547d26116100a1578063e687c3e91161007b578063e687c3e914610608578063f5f10b6514610638578063fb0c60a114610668578063fe71659c14610698576101b3565b8063ba547d2614610578578063c3a9b1f3146105a8578063def4d178146105d8576101b3565b806387f39b92116100dd57806387f39b92146104b85780638a7b032c146104e857806393ea9c1414610518578063afed762b14610548576101b3565b806373abf5f91461042857806375ad988d146104585780637a92f80f14610488576101b3565b806333fc12a9116101705780634a5f55481161014a5780634a5f5548146103685780634b5e282a146103985780634d5ed07a146103c8578063668c6738146103f8576101b3565b806333fc12a9146102d857806343ec3f3814610308578063486299a914610338576101b3565b80630a33d3da146101b8578063166c4b85146101e85780631c52e2fc146102185780631f8e60581461024857806321512c92146102785780632b8a41ef146102a8575b600080fd5b6101d260048036038101906101cd9190611bf7565b6106c8565b6040516101df9190611dcd565b60405180910390f35b61020260048036038101906101fd9190611b8d565b6106d9565b60405161020f9190611e40565b60405180910390f35b610232600480360381019061022d9190611c74565b610838565b60405161023f9190611e25565b60405180910390f35b610262600480360381019061025d9190611cb0565b610950565b60405161026f9190611e25565b60405180910390f35b610292600480360381019061028d9190611c74565b6109fe565b60405161029f9190611db2565b60405180910390f35b6102c260048036038101906102bd9190611c74565b610a2b565b6040516102cf9190611db2565b60405180910390f35b6102f260048036038101906102ed9190611c74565b610aa3565b6040516102ff9190611e25565b60405180910390f35b610322600480360381019061031d9190611b8d565b610abd565b60405161032f9190611e25565b60405180910390f35b610352600480360381019061034d9190611c74565b610af0565b60405161035f9190611e40565b60405180910390f35b610382600480360381019061037d9190611bf7565b610b98565b60405161038f9190611e25565b60405180910390f35b6103b260048036038101906103ad9190611cb0565b610bb0565b6040516103bf9190611e25565b60405180910390f35b6103e260048036038101906103dd9190611c74565b610c7b565b6040516103ef9190611db2565b60405180910390f35b610412600480360381019061040d9190611c20565b610c91565b60405161041f9190611e03565b60405180910390f35b610442600480360381019061043d9190611c74565b610f13565b60405161044f9190611e25565b60405180910390f35b610472600480360381019061046d9190611c74565b610fad565b60405161047f9190611db2565b60405180910390f35b6104a2600480360381019061049d9190611bf7565b611006565b6040516104af9190611db2565b60405180910390f35b6104d260048036038101906104cd9190611c74565b611016565b6040516104df9190611e03565b60405180910390f35b61050260048036038101906104fd9190611bf7565b6110ea565b60405161050f9190611e03565b60405180910390f35b610532600480360381019061052d9190611c74565b61118c565b60405161053f9190611e25565b60405180910390f35b610562600480360381019061055d9190611bb6565b6111a6565b60405161056f9190611e25565b60405180910390f35b610592600480360381019061058d9190611c74565b6111d4565b60405161059f9190611e25565b60405180910390f35b6105c260048036038101906105bd9190611bf7565b611238565b6040516105cf9190611e40565b60405180910390f35b6105f260048036038101906105ed9190611c74565b611347565b6040516105ff9190611e25565b60405180910390f35b610622600480360381019061061d9190611c74565b6113e2565b60405161062f9190611de8565b60405180910390f35b610652600480360381019061064d9190611bf7565b61151c565b60405161065f9190611e25565b60405180910390f35b610682600480360381019061067d9190611c74565b611548565b60405161068f9190611e25565b60405180910390f35b6106b260048036038101906106ad9190611bf7565b611593565b6040516106bf9190611e40565b60405180910390f35b600081516020830151209050919050565b6000806000801b8314156106f1576000915050610833565b60006fffffffffffffffffffffffffffffffff80168460001c1614156107465760108161071e9190611ef9565b90507001000000000000000000000000000000008360001c6107409190611f4f565b60001b92505b600067ffffffffffffffff80168460001c16141561078b5760088161076b9190611ef9565b9050680100000000000000008360001c6107859190611f4f565b60001b92505b600063ffffffff80168460001c1614156107c8576004816107ac9190611ef9565b90506401000000008360001c6107c29190611f4f565b60001b92505b600061ffff80168460001c161415610801576002816107e79190611ef9565b9050620100008360001c6107fb9190611f4f565b60001b92505b600060ff80168460001c1614156108225760018161081f9190611ef9565b90505b80602061082f91906121df565b9150505b919050565b6108406119ff565b826020015182602001818152505060008360000151141561086e57600082600001818152505081905061094a565b60008060ff601f60208701510351169050608081101561089157600191506108bc565b60e08110156108a357600291506108bb565b60f08110156108b557600391506108ba565b600491505b5b5b84600001518211156109085784600001518460000181815250508460000151856020018181516108ec9190611ef9565b915081815250506000856000018181525050839250505061094a565b818560200181815161091a9190611ef9565b91508181525050818560000181815161093391906121df565b915081815250508184600001818152505083925050505b92915050565b6109586119ff565b600061097685600001518660200151866000015187602001516116d0565b90508083602001818152505084602001518161099291906121df565b85600001516109a191906121df565b83600001818152505084602001518114156109c65760008560000181815250506109f3565b836000015183600001516109da9190611ef9565b856000018181516109eb91906121df565b915081815250505b829150509392505050565b60008260200151610a2184600001518560200151856000015186602001516116d0565b1415905092915050565b6000816000015183600001511015610a465760009050610a9d565b6000826000015184600001518560200151610a619190611ef9565b610a6b91906121df565b90508260200151811415610a83576001915050610a9d565b600083516020850151818120828520149250505080925050505b92915050565b610aab6119ff565b610ab6838383610950565b5092915050565b610ac56119ff565b6040516020810160405282815280602083015250610ae2826106d9565b816000018181525050919050565b6000808260000151610b148560000151866020015186600001518760200151611809565b610b1e9190611ef9565b90505b83600001518460200151610b359190611ef9565b8111610b91578180610b46906122da565b9250508260000151610b80856020015183610b6191906121df565b8660000151610b7091906121df565b8386600001518760200151611809565b610b8a9190611ef9565b9050610b21565b5092915050565b610ba06119ff565b610baa8282610838565b50919050565b610bb86119ff565b6000610bd68560000151866020015186600001518760200151611809565b90508460200151836020018181525050846020015181610bf691906121df565b83600001818152505084600001518560200151610c139190611ef9565b811415610c2a576000856000018181525050610c70565b83600001518360000151610c3e9190611ef9565b85600001818151610c4f91906121df565b91508181525050836000015181610c669190611ef9565b8560200181815250505b829150509392505050565b600080610c8884846113e2565b14905092915050565b6060600082511415610cb457604051806020016040528060008152509050610f0d565b600060018351610cc491906121df565b8460000151610cd391906120f1565b905060005b8351811015610d4657838181518110610d1a577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b60200260200101516000015182610d319190611ef9565b91508080610d3e906122da565b915050610cd8565b5060008167ffffffffffffffff811115610d89577f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6040519080825280601f01601f191660200182016040528015610dbb5781602001600182028036833780820191505090505b509050600060208201905060005b8551811015610f0557610e6582878381518110610e0f577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b602002602001015160200151888481518110610e54577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b602002602001015160000151611953565b858181518110610e9e577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b60200260200101516000015182610eb59190611ef9565b915060018651610ec591906121df565b811015610ef257610edf8288602001518960000151611953565b866000015182610eef9190611ef9565b91505b8080610efd906122da565b915050610dc9565b508193505050505b92915050565b610f1b6119ff565b816000015183600001511015610f3357829050610fa7565b6000600190508260200151846020015114610f61578251602085015160208501518281208383201493505050505b8015610fa257826000015184600001818151610f7d91906121df565b91508181525050826000015184602001818151610f9a9190611ef9565b915081815250505b839150505b92915050565b6000816000015183600001511015610fc85760009050611000565b816020015183602001511415610fe15760019050611000565b6000825160208501516020850151828120838320149350505050809150505b92915050565b6000808260000151149050919050565b606060008260000151846000015161102e9190611ef9565b67ffffffffffffffff81111561106d577f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6040519080825280601f01601f19166020018201604052801561109f5781602001600182028036833780820191505090505b50905060006020820190506110bd8186602001518760000151611953565b6110df8560000151826110d09190611ef9565b85602001518660000151611953565b819250505092915050565b60606000826000015167ffffffffffffffff811115611132577f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6040519080825280601f01601f1916602001820160405280156111645781602001600182028036833780820191505090505b50905060006020820190506111828185602001518660000151611953565b8192505050919050565b6111946119ff565b61119f838383610bb0565b5092915050565b6111ae6119ff565b600060208301905060405180604001604052808451815260200182815250915050919050565b6111dc6119ff565b60006111fa8460000151856020015185600001518660200151611809565b905083602001518161120c91906121df565b8460000181815161121d91906121df565b91508181525050808460200181815250508391505092915050565b600080601f836020015161124c91906121df565b905060008360000151826112609190611ef9565b9050600092505b8082101561134057600060ff835116905060808160ff161015611298576001836112919190611ef9565b925061132c565b60e08160ff1610156112b8576002836112b19190611ef9565b925061132b565b60f08160ff1610156112d8576003836112d19190611ef9565b925061132a565b60f88160ff1610156112f8576004836112f19190611ef9565b9250611329565b60fc8160ff161015611318576005836113119190611ef9565b9250611328565b6006836113259190611ef9565b92505b5b5b5b5b508280611338906122da565b935050611267565b5050919050565b61134f6119ff565b816000015183600001511015611367578290506113dc565b60008260000151846000015185602001516113829190611ef9565b61138c91906121df565b9050600060019050836020015182146113b2578351602085015181812082852014925050505b80156113d6578360000151856000018181516113ce91906121df565b915081815250505b84925050505b92915050565b6000808360000151905083600001518360000151101561140457826000015190505b60008460200151905060008460200151905060005b838110156114fb5760008084519150835190508082146114c75760007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff905060208710156114a15760018488602061147191906121df565b61147b9190611ef9565b600861148791906120f1565b60026114939190611fd3565b61149d91906121df565b1990505b6000818316828516039050600081146114c4578098505050505050505050611516565b50505b6020856114d49190611ef9565b94506020846114e39190611ef9565b935050506020816114f49190611ef9565b9050611419565b5084600001518660000151611510919061214b565b93505050505b92915050565b6115246119ff565b60405180604001604052808360000151815260200183602001518152509050919050565b6115506119ff565b600061156e84600001518560200151856000015186602001516116d0565b905083602001518161158091906121df565b8460000181815250508391505092915050565b600080826000015114156115aa57600090506116cb565b60008060007f010000000000000000000000000000000000000000000000000000000000000090506020850151519250600081846115e89190611f4f565b905060808110156115ff578094506001925061163c565b60e081101561161757601f811694506002925061163b565b60f081101561162f57600f811694506003925061163a565b600781169450600492505b5b5b85600001518311156116555760009450505050506116cb565b6000600190505b838110156116c557610100836116729190611f4f565b925060ff83866116829190611f4f565b169150608060c083161461169e576000955050505050506116cb565b603f82166040876116af91906120f1565b17955080806116bd906122da565b91505061165c565b50505050505b919050565b6000808584116117fc5760208411611798576000808511156117245760018560206116fb91906121df565b600861170791906120f1565b60026117139190611fd3565b61171d91906121df565b1960001b90505b60008185511690508588886117399190611ef9565b61174391906121df565b925060008284511690505b818114611781578784116117685787945050505050611801565b83806117739061227f565b94505082845116905061174e565b868461178d9190611ef9565b945050505050611801565b6000848420905084876117ab91906121df565b866117b69190611ef9565b91505b8582106117fa5760008583209050808214156117e55785836117db9190611ef9565b9350505050611801565b6001836117f291906121df565b9250506117b9565b505b849150505b949350505050565b600080849050600086851161193a57602085116118dc5760008086111561186257600186602061183991906121df565b600861184591906120f1565b60026118519190611fd3565b61185b91906121df565b1960001b90505b60008186511690506000878a8a6118799190611ef9565b61188391906121df565b905060008386511690505b8281146118ce578186106118b5578a8a6118a89190611ef9565b965050505050505061194b565b85806118c0906122da565b96505083865116905061188e565b85965050505050505061194b565b60008585209050600091505b85886118f491906121df565b8211611938576000868420905080821415611915578394505050505061194b565b6001846119229190611ef9565b9350508180611930906122da565b9250506118e8565b505b86866119469190611ef9565b925050505b949350505050565b5b60208110611992578151835260208361196d9190611ef9565b925060208261197c9190611ef9565b915060208161198b91906121df565b9050611954565b60007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff905060008211156119e95760018260206119cf91906121df565b6101006119dc9190611fd3565b6119e691906121df565b90505b8019835116818551168181178652505050505050565b604051806040016040528060008152602001600081525090565b6000611a2c611a2784611e80565b611e5b565b90508083825260208201905082856040860282011115611a4b57600080fd5b60005b85811015611a7b5781611a618882611b2c565b845260208401935060408301925050600181019050611a4e565b5050509392505050565b6000611a98611a9384611eac565b611e5b565b905082815260208101848484011115611ab057600080fd5b611abb84828561223d565b509392505050565b600082601f830112611ad457600080fd5b8135611ae4848260208601611a19565b91505092915050565b600081359050611afc816123ce565b92915050565b600082601f830112611b1357600080fd5b8135611b23848260208601611a85565b91505092915050565b600060408284031215611b3e57600080fd5b611b486040611e5b565b90506000611b5884828501611b78565b6000830152506020611b6c84828501611b78565b60208301525092915050565b600081359050611b87816123e5565b92915050565b600060208284031215611b9f57600080fd5b6000611bad84828501611aed565b91505092915050565b600060208284031215611bc857600080fd5b600082013567ffffffffffffffff811115611be257600080fd5b611bee84828501611b02565b91505092915050565b600060408284031215611c0957600080fd5b6000611c1784828501611b2c565b91505092915050565b60008060608385031215611c3357600080fd5b6000611c4185828601611b2c565b925050604083013567ffffffffffffffff811115611c5e57600080fd5b611c6a85828601611ac3565b9150509250929050565b60008060808385031215611c8757600080fd5b6000611c9585828601611b2c565b9250506040611ca685828601611b2c565b9150509250929050565b600080600060c08486031215611cc557600080fd5b6000611cd386828701611b2c565b9350506040611ce486828701611b2c565b9250506080611cf586828701611b2c565b9150509250925092565b611d0881612213565b82525050565b611d178161221f565b82525050565b611d2681612229565b82525050565b6000611d3782611edd565b611d418185611ee8565b9350611d5181856020860161224c565b611d5a816123b0565b840191505092915050565b604082016000820151611d7b6000850182611da3565b506020820151611d8e6020850182611da3565b50505050565b611d9d81612233565b82525050565b611dac81612233565b82525050565b6000602082019050611dc76000830184611cff565b92915050565b6000602082019050611de26000830184611d0e565b92915050565b6000602082019050611dfd6000830184611d1d565b92915050565b60006020820190508181036000830152611e1d8184611d2c565b905092915050565b6000604082019050611e3a6000830184611d65565b92915050565b6000602082019050611e556000830184611d94565b92915050565b6000611e65611e76565b9050611e7182826122a9565b919050565b6000604051905090565b600067ffffffffffffffff821115611e9b57611e9a612381565b5b602082029050602081019050919050565b600067ffffffffffffffff821115611ec757611ec6612381565b5b611ed0826123b0565b9050602081019050919050565b600081519050919050565b600082825260208201905092915050565b6000611f0482612233565b9150611f0f83612233565b9250827fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff03821115611f4457611f43612323565b5b828201905092915050565b6000611f5a82612233565b9150611f6583612233565b925082611f7557611f74612352565b5b828204905092915050565b6000808291508390505b6001851115611fca57808604811115611fa657611fa5612323565b5b6001851615611fb55780820291505b8081029050611fc3856123c1565b9450611f8a565b94509492505050565b6000611fde82612233565b9150611fe983612233565b92506120167fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff848461201e565b905092915050565b60008261202e57600190506120ea565b8161203c57600090506120ea565b8160018114612052576002811461205c5761208b565b60019150506120ea565b60ff84111561206e5761206d612323565b5b8360020a91508482111561208557612084612323565b5b506120ea565b5060208310610133831016604e8410600b84101617156120c05782820a9050838111156120bb576120ba612323565b5b6120ea565b6120cd8484846001611f80565b925090508184048111156120e4576120e3612323565b5b81810290505b9392505050565b60006120fc82612233565b915061210783612233565b9250817fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff04831182151516156121405761213f612323565b5b828202905092915050565b600061215682612229565b915061216183612229565b9250827f80000000000000000000000000000000000000000000000000000000000000000182126000841215161561219c5761219b612323565b5b827f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0182136000841216156121d4576121d3612323565b5b828203905092915050565b60006121ea82612233565b91506121f583612233565b92508282101561220857612207612323565b5b828203905092915050565b60008115159050919050565b6000819050919050565b6000819050919050565b6000819050919050565b82818337600083830152505050565b60005b8381101561226a57808201518184015260208101905061224f565b83811115612279576000848401525b50505050565b600061228a82612233565b9150600082141561229e5761229d612323565b5b600182039050919050565b6122b2826123b0565b810181811067ffffffffffffffff821117156122d1576122d0612381565b5b80604052505050565b60006122e582612233565b91507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff82141561231857612317612323565b5b600182019050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6000601f19601f8301169050919050565b60008160011c9050919050565b6123d78161221f565b81146123e257600080fd5b50565b6123ee81612233565b81146123f957600080fd5b5056fea26469706673582212203544f9a906fe3caa53c25c4ddf7fd4886bc47f553c76f88bd925df9492795aeb64736f6c63430008040033",
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}